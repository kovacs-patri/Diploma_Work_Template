Ebben a fejezetben a fejlesztési dokumentációt mutatom be.
Először bemutatom a projekt forrásának könyvtárszerkezetét, felépítését, a főbb fájlokat, könyvtárakat, valamint a build konfigurációt.
Ezután megmutatom, hogy miképpen lehet egy alkalmazást regisztrálni a Strava weboldalán, majd rátérek  a szükséges Strava felhasználói adatok elérésének megvalósítására.
Ezt követően részletezem a játék logikájáért felelős osztályokat, illetve a két rész kapcsolatát, végül pedig szót ejtek a kinézet szerkesztéséről is.

\section{A projekt főbb fájljainak részletezése}\label{fobbFajlok}


A projekt könyvtárstruktúrája a \ref{fig_konyvtarStruktura} ábrán látható:

\Figure {konyvtarStruktura}{A projekt könyvtár struktúrája}{height=10cm}

Az \CodeName{App.java} egy futtatható osztály, ami mint a \ref{javafxMinta} fejezetben is említettem, ez tartalmazza az alkalmazás életciklus folyamataihoz szükséges metódusokat.
Metódusai közül a \CodeName{start} egy absztrakt metódus, melyet kötelezően felül kell írni.


\begin{lstlisting}[language=Java]
@Override
public void start(Stage primaryStage) throws Exception {
  primaryStage.setTitle("Strava");
  scene = new Scene(loadFXML("sample"));
  primaryStage.setScene(scene);
  primaryStage.show();
    }
\end{lstlisting}
 
A \CodeName{start} metódusban kell megadni a megjelenítendő \CodeName{Stage}-et, és annak beállításait.
A \CodeName{Scene} objektum a jelenetgráf összes tartalmazott elemének tárolója, mely a \CodeName{Stage}-n megjelenítendő view-t tartalmazó FXML-t várja az ablakméretre vonatkozó értékekkel együtt.
Ezt a \CodeName{Stage}-nek beállítva a \CodeName{show} metódussal érhetjük el, hogy megjelenjen rajta a \CodeName{Scene}.

Ez az osztály ezen kívül tartalmaz még egy \CodeName{setRoot} és egy \CodeName{main} metódust, valamint egy \CodeName{loadFXML} függvényt.
A \CodeName{loadFXML} függvény a megfelelő FXML fájl betöltéséért felel.

\begin{lstlisting}[language=Java]
private Parent loadFXML(String fxml) throws IOException {
  FXMLLoader fxmlLoader = new FXMLLoader
  (getClass().getClassLoader()
  .getResource(fxml + ".fxml"));
  return fxmlLoader.load();
    } 
\end{lstlisting}
 
Az FXML betöltéséért az \CodeName{FXMLLoader} osztály felel, mely a \CodeName{javafx.fxml} csomagban található.
Számos konstruktort tartalmaz, melyek segítségével betölthetjük a dokumentumot.
Egy \CodeName{FXMLLoader} típusú változó inicializálásával megadható, hogy honnan éri el az FXML fájlt.
A \CodeName{load} metódusa visszaadja \CodeName{Parent} típusként az FXML forrását.

A \CodeName{setRoot} nevű metódus beállítja az adott \CodeName{Scene}-hez a paraméterében megadott FXML-t.

\begin{lstlisting}[language=Java]
public void setRoot(String fxml) throws IOException {
  scene.setRoot(loadFXML(fxml));
    }
\end{lstlisting}
 

A main metódus pedig csak az \CodeName{Application} osztály \CodeName{launch} függvényét tartalmazza. 

\begin{lstlisting}[language=Java]
public static void main(String[] args) {
  launch();
    }
\end{lstlisting}

A \CodeName{POM.xml} fájl felépítésére a \ref{fig_pom} ábrán található egy minta.
Tartalmazza a projektre vonatkozó adatokat, mint például verziószám, projekt neve, kódolás. 
 
\Figure {pom}{A POM.XML fájl tartalma}{width=12cm}

 
Mint a \ref{fig_pom2} ábrán is látható, az alkalmazás függőséget is tartalmaz.
Az ábrán csak a JavaFX \CodeName{contols}-ra és az \CodeName{fxml}-re vonatkozóan, melyek elérhetőek a Maven Central Repository-ból. 
  
\Figure {pom2}{POM.XML fájl, függőségek}{width=12cm}

Ezalatt a build folyamathoz szükséges plugin-ok beállítása található, melyre egy példa a \ref{fig_build} ábrán látható: 


\Figure {build}{POM.XML fájl, build folyamatok}{width=12cm}


A \ref{fig_fxml} ábrán egy FXML fájl látható.

\Figure {fxml}{FXML fájl}{width=12cm}
 
Pont, mint egy XML dokumentumban, itt is minden elem egy nyitó és egy záró tag közé kerül.
Az FXML fájl XML deklarációval kezdődik.
Nem kötelező megadni, de ha definiáljuk, akkor csak a fenti sorrend helyes.
A verzió az adott FXML fájlra vonatkozó XML szabvány verzióját jelöli, az encoding pedig a fájlban használt karakterkészletet.
Ha nem adjuk meg az XML deklarációt, akkor alapértelmezettként az “\CodeName{1.0}” XML verziót használja és karakterkódolása pedig “\CodeName{UTF-8}” lesz.
A következő sorokban lévő import utasítások megfelelnek a Java kódban használt importálási utasításoknak.
Nem csak JavaFX-es importok használhatók az FXML-ben, hanem szimpla Java importok is, mint pl. \CodeName{java.util.ArrayList}.
Jelen esetben egy \CodeName{VBox}, egy \CodeName{Label} és egy \CodeName{Button} elemet használunk az adott view-n. 
 
Az \CodeName{AnchorPane} egy olyan elem a megjelenített felületen, melyen különféle elemeket lehet elhelyezni.
Az első sorában láthatjuk a rá vonatkozó tulajdonságokat és hogy milyen névteret használ.
Az \CodeName{fx:controller} deklarálásával adható meg, hogy a JavaFX alkalmazásban melyik kontroller osztály tartozik hozzá.
Lejjebb, az általa tartalmazott elemeket a nyitó és záró tagjei között megadott \CodeName{<children></children>} tagek közt sorolhatjuk fel.
Ezeknek az elemeknek szintén meg lehet adni különböző tulajdonságokat.

A szövegcímkén például ez itt csak a rajta lévő szöveg és az elhelyezkedése, a gombok esetében pedig ezeken kívül látható egy \CodeName{fx:id} és egy \CodeName{onAction} deklaráció, valamint a kinézetükre vonatkozó beállítások.
Az \CodeName{fx:id} tartalmazza a gomb id-ját, más osztályokból ezen a néven érhetjük el az adott elemet.
Az \CodeName{onAction} pedig a rá vonatkozó eseménykezelő funkciójának nevét tartalmazza, mely nevét \# jellel kell kezdeni.
Ezzel a névvel hivatkozhatunk más osztályokból a gomb ezen tulajdonságára.
Az FXML elemeket, eseménykezelők metódusait \CodeName{@FXML} annotációval kell ellátni a \CodeName{.java} osztályokban, ha ott használni szeretnénk őket.  



\section{Alkalmazás regisztrálása a Strava weboldalán}

A Strava API egy nyilvánosan elérhető interfész, ami hozzáférést biztosít a Strava adatbázisában tárolt adatok hozzáféréséhez.
Ahhoz, hogy használni lehessen a Strava API-t, először az applikációt regisztrálni kell a weboldalon.
Ezután a beállításokon belül létre kell hozni egy alkalmazást, melynek a \ref{fig_stravaApp} ábrán látható adatainak segítségével kéréseket lehet küldeni a szerver felé. 

\Figure {stravaApp}{Strava alkalmazás adatai}{width=10cm}

A kérések küldéséhez szükség van autentikációra, melyhez a Strava az OAuth2-t használja.
Az OAuth elindulása után szükség van a felhasználó bejelentkezésére a Strava weboldalán, hogy engedélyezze az alkalmazás számára a hozzáférést.
Ez a \ref{fig_stravaAuth} ábrán látható. 

\Figure {stravaAuth}{Strava authorizáció megerősítése}{width=10cm}

Miután ez megtörtént, átirányítja a felhasználót egy másik URL címre, mely tartalmaz egy rövid életű kódot, amit felhasználhat az autorizációhoz.
Ez a kód, a Client ID-vel és a Client Secret-tel együtt felhasználható egy kérésre, amellyel le lehet kérni a felhasználóra vonatkozó információkat.
Az Access Token az azonosított felhasználó adatainak eléréséhez szükséges, 6 óránként megújul.
A Refresh Token új Access Token beszerzésére szolgál, ha az lejárt.

\section{Strava adatok elérésének megvalósítása}

A feladat megvalósításához elengedhetetlen az adott Strava felhasználó különféle adatainak elérése, annak a weboldalra feltöltött aktivitásaira vonatkozó információit is beleértve.
Ezen adatokhoz többféleképpen is hozzá lehet férni.
Lehetséges a Strava publikus API-ján keresztül, vagy akár csak egyszerű HTTP kérésekkel is. 

A nyilvános API a Swagger Codegen kódgenerátor segítségével generálható le a hozzá tartozó URL címen található JSON fájlból, különböző programozási nyelvekre.\cite{strava}
Itt látható egy minta parancs az API kódjának generálására: 

\begin{lstlisting}[language=Java]
$ swagger-codegen generate -i https://developers.strava.com/swagger/swagger.json -l java -o generated/java 
\end{lstlisting}

A \CodeName{-i} kapcsoló szolgál azon URL cím megadására, amelyen elérhető a generálandó kód.
A \CodeName{-l} kapcsolóval lehet megjelölni, hogy mely programozási nyelven szeretnénk megkapni az eredményt, a \CodeName{-o} beírása után pedig a célkönyvtár elérési útját kell megadni.
Hogy mely nyelveket támogatja a Swagger Codegen, azt a \CodeName{swagger-codegen} parancs önmagában való futtatásával lehet kilistázni.
A fenti parancsot lefuttatva a Strava API-ja java nyelven kerül legenerálásra a \CodeName{generated/java} mappába.
Mivel az én programomban nem volt szükség összetettebb funkciók használatára a szükséges adatok eléréséhez, így elegendőnek láttam ezeket inkább csak egyszerű HTTP kérésekkel megoldani.
A kész projekt könyvtárstruktúrája a \ref{fig_konyvtarStruktura} ábrán látható: 

\Figure {konyvtarStruktura}{A projekt könyvtár struktúrája}{height=12cm}


Programomban a felhasználó Strava adataihoz való hozzáféréshez és ezek tárolásához a következő osztályok felelősek: 

\begin{itemize}
\setlength\itemsep{0em}
\item \CodeName{Controller}
\item \CodeName{HttpRequest}
\item \CodeName{StravaLogin}
\item \CodeName{User}
\end{itemize}
 

Az \CodeName{App} nevű futtatható osztály tartalmazza a program indításához szükséges beállításokat, a \CodeName{sample.fxml} fájl betöltését is beleértve.
A \CodeName{Controller} osztály felel a bejelentkezés lebonyolításáért, a kapcsolat frissítéséért, a felhasználó beállításáért, valamint az FXML fájlban lévő komponensekre vonatkozó események irányításáért.
A \CodeName{HttpRequest} osztály tartalmaz egy \CodeName{HTTP POST} kérésért felelős függvényt, mely egy JSON objektummal tér vissza, valamint egy \CodeName{HTTP GET} kérésre vonatkozó függvényt, aminek pedig a visszatérési értéke egy \CodeName{JSONArray}.
A Strava felhasználó adatai eléréséhez szükséges URL címeket, illetve az ezeket kiegészítő Client Id és Client Secret kódokat a \CodeName{StravaLogin} osztály tartalmazza.
Végül pedig a \CodeName{User} osztály a bejelentkezett felhasználóra vonatkozó adatokat tárolja, illetve azokkal történő számításokat végez. 

Ezen osztályoknak a célja, hogy a programon belül megtörténjen a felhasználó bejelentkezése, az adatainak és az aktivitási listájának elérése, az ezekből származó megtett távolságokkal való számolás, illetve pontok gyűjtése a felhasználó számára.
A következőkben leírom ennek a megvalósítását, amit a \CodeName{Controller} osztály részletesebb ismertetésével kezdek. 

A program felhasználói felületén elhelyeztem egy \CodeName{WebView-}t, mely a \CodeName{javafx.scene.web} csomagjában található, és webes felület megjelenítésére szolgál.
Az autentikációhoz szükséges URL a következő, melyet a \CodeName{WebView}-hoz beállított \CodeName{WebEngine} megpróbál betölteni: 

\url{
https://www.strava.com/oauth/authorize?client_id=[CLIENT_ID]&response_type=code&redirect_uri=http://localhost&approval_prompt=force&scope=activity:read_all 
}

Az URL-ben szereplő \CodeName{[CLIENT\_ID]} a Strava weboldalán bejelentkezett felhasználóként létrehozott App Client Id-jével kiegészítendő.
Mivel az autentikációra való engedély megadása csak a Strava oldalára való bejelentkezés után érhető el, így ennek az URL-nek a betöltésére a \url{https://www.strava.com/login} címre irányít át, ahol el kell végezni a bejelentkezést.
Ezután már betöltődik az autentikációhoz szükséges cím, melyen meg kell adni az engedélyt a folytatáshoz.
Amint ez megtörtént, egy olyan URL-re következik az átirányítás, mely tartalmazza a szükséges tokenek beszerzéséhez szükséges kódot.
Ez a cím tartalmazza a \CodeName{localhost/} szövegrészt, így erre beállítottam egy \CodeName{Listener}-t, mely az URL változását figyeli.
Ha tartalmazza a \CodeName{localhost/} szövegrészt, az azt jelenti, hogy megtörtént az autentikáció.
Ebben az esetben meghívódik egy metódus, amely a legutóbb betöltött címből eléri a szükséges kódot, ezt beilleszti az Access és a Refresh Token kéréséhez szükséges URL-be, majd lefut a tokenek beszerzéséért felelős metódus. 

\begin{lstlisting}[language=Java]
public void webViewLogin() { 
  webPane.setVisible(true); 
  login.setWebEngine(webView.getEngine()); 
  login.getWebEngine().getLoadWorker().stateProperty(). 
  addListener((ov, oldState, newState) -> { 
  webPane.setVisible(false); 
  loginPane.setVisible(true);
  apiRequest(login.getWebEngine().getLocation()); 
    deleteFile(); 
    createAthleteObject(); 
    loginPane.setVisible(true); 
     } 
   }); 
  login.getWebEngine().load(login.getAuthURL()); 
    } 
\end{lstlisting}
 

A kapcsolat megnyitásához szükséges Access Token-t, illetve a későbbiekben az ezt frissítő Refresh Token-t a következő URL címre történő HTTP POST kéréssel kapom meg, ahol a \CodeName{[CLIENT\_ID]} és \CodeName{[CLIENT\_SECRET]} a Strava weboldalán létrehozott App Client Id-jével, és Client Secret-ével kiegészítendő:

\url{
https://www.strava.com/oauth/token?client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET] 
}

A válasz egy JSON objektum, mely tartalmazza az Access Token-t, a Refresh Token-t, illetve hogy az Access Token meddig érvényes Unix epoch időben, ami a UTC 1970.01.01. éjféltől eltelt másodpercek száma , valamint tartalmazza még a felhasználóra vonatkozó általános adatokat, úgy, mint a neve, neme, lakhelye, stb.
Itt beállítom a felhasználóhoz a két tokent, illetve a lejárati időt, valamint a játékos nevét.
A \CodeName{java.time.Instant} programcsomag tartalmaz egy \CodeName{Instant.now().getEpochSecond()} függvényt, mely visszaadja az éppen jelenlegi rendszeridőt epoch másodpercben, ezzel hasonlítom össze egy metódusban az eltárolt lejárati időt az aktuális rendszeridővel. 

Ha lejárt a token, akkor a következő URL címre küldve egy HTTP POST kérést megkapom az új Access Token-t, és ennek lejáratát:

\url{
https://www.strava.com/oauth/token?client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET]&refresh_token=[REFRESH_TOKEN]&grant_type=refresh_token 
}

Az URL-ben lévő \CodeName{[CLIENT\_ID]} és \CodeName{[CLIENT\_SECRET]} a már korábban említett Client Id-t és Client Secret-et jelenti, a \CodeName{[REFRESH\_TOKEN]}-t pedig a bejelentkezett felhasználóhoz beállított \CodeName{User} objektumból érem el.
A válasz pedig szintén egy JSON objektum, de ez csak a tokenekre vonatkozó információkat tartalmazza. 

Amint megtörtént a bejelentkezés, megtörténik a \CodeName{User} aktivitási listájának lekérdezése.
A következő URL-re történő HTTP GET kéréssel megkapható a felhasználó aktivitási listája, mely \CodeName{JSONArray}-ként érkezik a válaszban, amit eltárolok a \CodeName{User} objektumban:

\url{
https://www.strava.com/api/v3/athlete/activities?access_token=[ACCESS_TOKEN] 
}

Ezeken kívül ebben az osztályban történnek még a különböző gombokra vonatkozó események kezelése is. 

A \CodeName{HttpRequest} osztály csak két függvényt tartalmaz, a HTTP kérésekre vonatkozóan.
Csak a POST függvényt részletezem, mivel a kettő között csak a visszatérési értékben és a kérés típusában van lényeges különbség.


\begin{lstlisting}[language=Java]
public JSONObject httpPOST(String urlString){
  JSONObject myResponse = new JSONObject();
  try {
    URL url = new URL(urlString);
    HttpURLConnection conn = (HttpURLConnection)
    url.openConnection();
    conn.setRequestMethod("POST");
    conn.setDoOutput(true);
    Reader in = new BufferedReader(new InputStreamReader
    (conn.getInputStream(), "UTF-8"));
    StringBuilder sb = new StringBuilder();
    for (int c; (c = in.read()) >= 0;) {
      sb.append((char) c);
      }
    String response = sb.toString();
    myResponse = new JSONObject(response.toString());   
    } catch (IOException e) {
      Logger.getLogger(HttpRequest.class.getName()).log(Level.SEVERE, null, e);
      }
    return myResponse;
    }
\end{lstlisting}


A \CodeName{java.net} programcsomagja tartalmazza az URL és a \CodeName{HttpURLConnection} osztályokat, melyeket a kapcsolat megnyitására használtam a szóban forgó függvényekben.
Az elérni kívánt URL címét String-ként kapja meg a függvény, melyet URL objektummá alakít, ezután megnyitja erre a kapcsolatot.
Beállítottam a kérés típusát, jelen esetben POST-ot, mely output-ját egy \CodeName{StringBuilder} változóba összefűzi, majd ezt a választ átadja egy JSON objektumnak, amivel a függvény visszatér. 

A \CodeName{User} osztályban a bejelentkezett felhasználóra vonatkozó információkat, valamint az ezeket beállító és lekérő metódusokat tárolom, illetve itt találhatók meg a megtett távolságokat és a pontokat számoló függvények.
A felhasználóról a következő adatokat tárolom: 

\begin{itemize}
\setlength\itemsep{0em}
\item név 
\item id 
\item access token 
\item refresh token 
\item token lejárati ideje 
\item utolsó aktivitásának id-je 
\item az összes megtett útja 
\item a jelenleg felhasználható pontja 
\item az eddig elköltött pontjai 
\item a játékba való belépésénél számított legutóbbi aktivitás id-je 
\item az összes aktivitásának listája
\end{itemize}

\section{Játék logika megvalósítása}

Magához a játék megvalósításához öt Java osztályt és egy hozzá tartozó FXML fájt készítettem.
A Java osztályok név szerint a következők: 

\begin{itemize}
\setlength\itemsep{0em}
\item \CodeName{Country}
\item \CodeName{CountryDiceRoll}
\item \CodeName{GameEngine}
\item \CodeName{MapFXMLController}
\item \CodeName{Map}
\end{itemize}

A következőkben ezen osztályok tartalmát részletezem.

\subsection*{A Country és a CountryDiceRoll osztály}

A \CodeName{Country} osztály tartalmazza a megyékre vonatkozó információkat, úgy, mint az id-je, mely egy egyedi azonosító, magában foglalja, hogy hány katona van az adott területen, annak birtokosát, és mivel körökkel jelöltem meg a felületen a megyéket, így a hozzá tartozó, \CodeName{javafx.scene.shape} csomag által nyújtott kört is itt tárolom, valamint az ezen megjelenő szöveget is, mely a területen tartózkodó katonák számát jeleníti meg. 

Ebben az osztályban találhatók még az ezeket lekérő, illetve beállító metódusok, valamint különböző függvények arra vonatkozóan, hogy eldöntésre kerüljön, hogy két megye ugyanannak a játékosnak a birtokában van-e, hogy az adott területről hány katonával támadhat és hánnyal védekezhet, továbbá egy másik terület megtámadására vonatkozó függvény. 

A területről támadó katonák maximális száma 3, a védekezőé pedig 2.
A támadás kockadobásokkal történik, amelyért felelős függvények a \CodeName{CountryDiceRoll} osztályban találhatók meg.
Itt kerül tárolásra a támadó és a védekező fél kockadobásainak listája, a legnagyobb dobás mindkét fél részéről, valamint, hogy hány oldalú a dobókocka és az ezeket beállító, illetve lekérő függvények és metódusok.
A kockadobások csökkenő sorrendbe rendezéséért is ennek az osztálynak egy függvénye felel. 

A \CodeName{Country} osztály tehát a támadásra vonatkozó metódusában ezt használja annak eldöntésére, hogy egy támadás során melyik fél veszít katonát.
Egy támadás során vagy az egyik, vagy a másik fél elveszít egy katonát.
Amelyik fél nagyobbat dob, az nyer, az ellenféltől pedig levonásra kerül egy katona.
Ha megegyezik a két legnagyobb dobás, abban az esetben a védekező fél nyeri a csatát, vagyis a támadó elveszít egy katonát.

\subsection*{A Map osztály}

A \CodeName{Map} osztály egy \CodeName{HashMap}-et tartalmaz a megyék szomszédosságaira vonatkozóan, melynek feltöltése egy JSON fájlból történik.
A \CodeName{HashMap} tartalmát visszaadó függvényen kívül még a szomszédosságra vonatkozó függvényeket tartalmaz, úgy, mint annak ellenőrzése, hogy két adott megye szomszédos-e, egy megye szomszédsági listája tartalmazza-e a paraméterben megadott megyét, valamint egy adott megye szomszédsági listájának visszaadására vonatkozó függvényt. 

\subsection{A GameEngine osztály}

A \CodeName{GameEngine} nevű osztály a játékmenetre vonatkozó dolgokat foglalja magában.
Tartalmazza a megyék kapcsolatait, valamint azok \CodeName{Country} objektumokkal feltöltött listáját, a játékosok listáját, azt, hogy a játékban eddig ki, melyik megyével melyik megyét támadta és mik voltak a dobások, a játék fázisokat, hogy hány katonát kaphatnak a játékosok az adott körben az erősítési fázisban, jelenleg hányadik körben zajlik a játék és a nyertest. 

Magában foglalja még az ezeket beállító és lekérő metódusokat.
Itt történik még a \CodeName{Country} objektumok létrehozása véletlenszerűen vagy fájlból betöltve, a játék fázisok állítása, az ezektől függő, a felületen megjelenő szövegek állítása, a játékosok léptetése az adott kör végén, ellenőrzések arra vonatkozóan, hogy az adott megye meg tudja-e támadni a kiválasztott ellenfelet, vagy sem, a szomszédos megyék közül két megye szövetségesek-e vagy ellenfelek, annak ellenőrzése, hogy van-e már nyertes, majd ennek beállítása.
A következőkben ezeket fogom részletesebben leírni. 

Az osztály konstruktorában paraméterként vár egy boolean és egy String változót arra vonatkozóan, hogy új játék betöltésére kerül-e sor, vagy nem és ha nem, akkor milyen nevű fájlt töltsön be.
Feltöltésre kerül a kapcsolati lista.
A játékos és a gép hozzáadása a játékos listához is itt történik.
Új játék indítása esetén egy olyan metódus hívódik meg, amely a kapcsolati listán végigmenve létrehozza az ehhez tartozó \CodeName{Country} objektumokat a megfelelő id-vel, 10 és 15 közötti véletlenszerű katonaszámmal, melyet a \CodeName{java.util.concurrent.ThreadLocalRandom} csomag \CodeName{ThreadLocalRandom.current().nextInt()} függvényével számoltam. 

Amennyiben nem új játék indítására kerülne a sor, hanem már létező mentés betöltésére, úgy egy JSON fájlból olvasó metódus kerül lefutásra.
Ez a konstruktorban megadott String változó nevét kéri paraméterként, ezzel a névvel ellátott fájlt próbálja meg beolvasni.
A fájl három \CodeName{JSONArray} listájából nyeri ki a szükséges adatokat.
Az első lista a megyékre vonatkozik, innét kapja meg a megyék id-jét, a rajtuk lévő katonák számát és a birtokosukat.
Egy for ciklusban erre vonatkozóan feltöltésre kerül a megyék listája.
A következő vizsgált \CodeName{JSONArray} a játékban eddig történő kockadobásokra vonatkozik.
Ismét egy for ciklus segítségével zajlik az eddigi dobási lista feltöltése, úgy, mint a játékállás feltöltésénél. Itt a játék aktuális fázisa, az erősítési fázisban elérhető katonák száma, az aktuális játékos id-je kerül feltöltésre, valamint az, hogy hányadik körben áll a játék. 

A játék fázisai \CodeName{Enum}-okkal vannak jelölve.
A fázisok sorban a következők: 

\begin{itemize}
\setlength\itemsep{0em}
\item \CodeName{REINFORCE}
\item \CodeName{SELECT\_REGION}
\item \CodeName{SELECT\_ENEMY}
\item \CodeName{ATTACK}
\item \CodeName{MOVE\_SELECT\_FIRST}
\item \CodeName{MOVE\_SELECT\_SECOND}
\end{itemize}

A \CodeName{REINFORCE} az erősítési fázist jelzi, itt történik az adott körben felhasználható katonák hozzáadása a saját területekhez, egyesével.
A \CodeName{SELECT\_REGION} az erősítést követő, azt a saját terület kiválasztását jelöli, amivel támadni szeretne a játékos, a \CodeName{SELECT\_ENEMY} azt jelzi, hogy ellenfél választása következik épp, \CodeName{ATTACK} fázisba lép, amint támadás történt és amíg zajlik.
Ezt követően következik a \CodeName{MOVE\_SELECT\_FIRST}, amely a saját katonák egy másik, saját, szomszédos területre való átcsoportosítását jelzi, annak is azt a részét, amikor olyan területet kell kijelölni, amelyről át szeretnénk vinni a katonákat máshová.
A \CodeName{MOVE\_SELECT\_SECOND} pedig az utolsó fázis egy játékos körében, amikor ki kell választani, hogy hová szeretnénk áthelyezni a katonákat. 

A kör végén megtörténik a felhasználható katonák számának beállítása, az aktuális játékos a következő játékosra való léptetése, valamint a \CodeName{REINFORCE} fázis beállítása.
A különböző fázisokban történő megyékkel kapcsolatos ellenőrzések, valamint a támadással kapcsolatos metódus is ebben az osztályban találhatók meg. 

Két megye akkor ellenfél, ha különböző a birtokosuk.
Egy megye csak akkor tud megtámadni egy másikat, ha szomszédok és különböző játékos birtokolja őket.
Két megye akkor szövetséges, ha ugyanaz a játékos birtokolja őket.
Külön függvényben szerepel, ha ők emellett szomszédok is. 

A \CodeName{GameEngine} osztály tartalmaz még egy megye elfoglalására vonatkozó metódust, mely átállítja az elfoglalt terület birtoklójának nevét a támadó nevére, valamint a két megye katona számát is beállítja.
Az elfoglalt területen annyi katona lesz, amennyivel a támadó megtámadta, a támadó területén pedig ennyivel kevesebb.
A játék nyertesének eldöntése pedig annak ellenőrzésével történik, hogy a játékosoknak van-e még olyan területe, amelyről támadni tud, ha valamelyiknek nincs már ilyen, akkor vége a játéknak. 

\subsection*{A MapFXMLController osztály}

Végül pedig a \CodeName{MapFXMLController} osztály tartalmazza az FXML fájlban lévő komponensekre vonatkozó események irányításáért és a felület változásáért felelős metódusokat, valamint itt zajlik a játékmenet irányítása, az ehhez kapcsolódó függvények is itt találhatók.
A következőkben ezeket részletezem. 

Az osztály magában foglal a \CodeName{GameEngine} osztályból egy példányt, az aktuálisan kiválasztott területekhez kapcsolódó változókat, a gép választható területeire vonatkozó listát, illetve az aktuálisan kiválasztott terület szomszédossági listáit a szövetségesekre, valamint az ellenfelekre vonatkozóan.
Az FXML dokumentumban megfogalmazott \CodeName{ArrayList} objektumot a térképen lévő köröket tartalmazó \CodeName{StackPane} elemekhez kapcsolódóan, valamint több más, FXML objektumot, melyek valamilyen formában módosításra kerülnek a program futása során. 

Ezeken kívül tartalmaz még a Strava bejelentkezéséért felelős \CodeName{Controller} osztályából és a \CodeName{WriteAndReadJSON} osztályból egy példányt, továbbá az új játékra és a mentésre vonatkozó változókat, de ezeket majd egy későbbi pontban fejtem ki, amikor a két kontroller osztály kapcsolatáról lesz szó. 

A \CodeName{start} metódusban történik meg a \CodeName{GameEngine} példány inicializálása, beállításra kerülnek a \CodeName{StackPane}-ekre vonatkozó tulajdonságok, úgy, mint a hozzájuk tartozó megye, a feliratuk, a körük, valamint az eseménykezelők, mely a \CodeName{StackPane}-ekre történő egérkattintásra hívódik meg.
Itt zajlik még a \CodeName{javafx.scene.control} csomagja által biztosított \CodeName{Tooltip} objektum beállítása minden egyes \CodeName{StackPane}-re, mely arra szolgál, hogy a kurzort fölé húzva megjelenítsen az egérmutató mellett egy szöveget, ami ebben az esetben a megyék teljes nevei, melyek a \CodeName{GameEngine} osztály egyik függvényéből kerülnek kinyerésre id alapján.
Ezután ebben a metódusban a GUI frissítése is megtörténik, illetve a felületen megjelenő különböző \CodeName{Label} objektumok értékeinek beállítása is. 

A GUI frissítéséért felelős függvény az alapértelmezettre állítja a \CodeName{Label}-ek értékeit, emellett a köröket is beállítja egy másik metódusban meghatározott alap színükre, amely a megyék tulajdonosai szerint állítja be a színeket. A \CodeName{StackPane}-ekre beállított eseménykezelő az azokra való egérkattintások hatására lép működésbe.
Elsősorban azt ellenőrzi, hogy a játékos körében történt-e a kattintás.
Ha nem, akkor nem történik semmi, ha pedig igen, akkor \CodeName{switch-case} ágak segítségével ellenőrzi a \CodeName{GameEngine} osztálytól lekért aktuális fázist, és ettől függően más-más működés lép életbe a \CodeName{StackPane}-ekre kattintva.

\subsection*{A játékos köre}

Ha a \CodeName{REINFORCE} fázisban történt a kattintás, ellenőrzésre kerül, hogy a játékosnak vannak-e elérhető katonái a \CodeName{GameEngine} osztályban, melyeket elhelyezhet ebben a fázisban a saját területein.
Ha igen, akkor ezek száma csökken 1-el, és ez hozzáadásra kerül az adott \CodeName{StackPane}-hez tartozó \CodeName{Country} objektum katonák számát tároló változójának értékéhez.
Amint a lehelyezhető katonák száma eléri a nullát, vagy a fázis lezáró gombra kattintás történik, a \CodeName{REINFORCE} fázis véget ér, és \CodeName{SELECT\_REGION} fázisba lép a program, majd az elérhető katonák száma megváltoztatásra kerül olyan értékre, mely a későbbiekben a gép számára lesz felhasználható. 

A \CodeName{SELECT\_REGION} állapotban bekövetkező kattintás hatására egy olyan metódus hívódik meg, ami ellenőrzi, hogy megfelelő, vagyis saját megyére történt-e a kattintás.
Amennyiben igen, tárolásra kerül a kijelölt terület id-je, és a jelenlegi fázistól függően a választott terület által megtámadható területek listájához hozzáadásra kerülnek az ehhez elérhető megyék egyedi azonosítói, mely a \CodeName{GameEngine} osztály erre vonatkozó függvényével kerül ellenőrzésre. 

Ennek vizuális szemléltetésére egy olyan metódus meghívására kerül sor, mely a körök színeit, átlátszóságát, valamint a rajtuk elhelyezett \CodeName{javafx.scene.effect} csomag által biztosított \CodeName{Effect}-et módosítja.
Amennyiben a kiválasztott területről lehetséges a támadás, vagyis több, mint 1 katona van rajta, illetve \CodeName{SELECT\_REGION} vagy \CodeName{SELECT\_ENEMY} állapotban van a játék, a támadható szomszédok köreinek színe pirosra állítódik és \CodeName{Lighting Effect} kerül rájuk, az összes többi átlátszósága felére csökken, a kiválasztott körét kivéve. 

Ha nem megfelelő \CodeName{StackPane}-re történt a kattintás, akkor a játék marad \CodeName{SELECT\_REGION} fázisban.
Helyes terület kiválasztása után a \CodeName{SELECT\_ENEMY} fázisra váltás következik.
Ebben az állapotban történő megyékre kattintáskor aktuális fázistól függően ellenőrzésre kerül, hogy a kiválasztott terület jelen esetben támadható-e a korábban kijelölt területről, vagy sem.
Amennyiben nem, úgy visszaáll a játékfázis \CodeName{SELECT\_REGION} állapotba és frissítésre kerül a GUI a fázishoz tartozó alap állapotba.
Ha pedig igen, úgy beállításra kerül a többi, támadható szomszéd átlátszósága világosabbra, csak a kijelölt ellenfél, valamint a korábban kiválasztott terület körének színe marad átlátszatlan, a jobb átláthatóság kedvéért, valamint a felületen megjelenítésre kerül egy \CodeName{Pane} a támadásra vonatkozóan.
Ez három gombot tartalmaz. 

Az egyik az ellenfél terület egyszeri megtámadására vonatkozik, a másik ennek addig történő támadására, amíg az lehetséges, a harmadik pedig a támadási szándék visszavonására.
Az egyszeri támadás gomb megnyomására \CodeName{ATTACK} fázisba lép a játék, és a \CodeName{GameEngine} támadásra vonatkozó függvényét meghívva lezajlanak a kockadobások és a vesztes fél elveszít egy katonát. 

A csatában résztvevő mindkét megye adatai frissítésre kerülnek, mely megjelenik a felületen is.
A játék aktuális köre, a támadó fél neve, a megye neve, amelyről a támadás történt, az ehhez tartozó legnagyobb kockadobás, valamint a védő terület neve, illetve a hozzá tartozó legnagyobb dobás hozzáadásra kerül egy kockadobási listára, mely a játékban történő eddigi összes támadás ezen adatait tárolja.
Ez a lista megjelenik a felületen egy gomb megnyomásának hatására, mely a felhasználó és a gép általi dobásokat is tartalmazza. 

Ha a támadás során az ellenfélnek már nem marad katonája, az elfoglalásra kerül a \CodeName{GameEngine} osztály erre vonatkozó metódusának meghívásával.
Ha a játékos támadó területén már csak egy katona maradt, akkor a támadás abbamarad.
A játék állapota mindkét eset után \CodeName{SELECT\_REGION}-ra változik, a felület frissítésre kerül a fázisnak megfelelően, a körök az alapértelmezett színükre változnak az új adatokkal.
A gombnyomás hatására ellenőrzésre kerül az is, hogy van-e a játéknak nyertese. 

A folyamatos támadásra vonatkozó gomb megnyomására addig történik automatikusan támadás, amíg az ellenfél területén van katona, vagy pedig a támadó fél területén egynél több katona található.
Ha elfogytak az ellenfél katonái a megtámadott megyén, akkor az elfoglalásra kerül és ismét \CodeName{SELECT\_REGION} fázisba kerül a játék, a GUI frissül.
Itt is ellenőrzésre kerül, hogy nyert-e közben valamelyik fél. 

A harmadik gomb megnyomása csak a kiválasztott ellenfél megye támadási szándékának visszavonására vonatkozik, megnyomására alaphelyzetbe áll a felület és ismét egy saját terület kiválasztására kerül sor. 

A \CodeName{StackPane}-ekre vonatkozó eseménykezelőben még a \CodeName{MOVE\_SELECT\_FIRST} és a \CodeName{MOVE\_SELECT\_SECOND} fázisokra történik még ellenőrzés.
Az előbbi állapotba a fázis lezáró gomb megnyomásának hatására van lehetőség átlépni.
\CodeName{ATTACK}, \CodeName{SELECT\_REGION}, \CodeName{SELECT\_ENEMY} fázisokban történő megnyomásakor \CodeName{MOVE\_SELECT\_FIRST} állapot lesz az aktuális. 

Ez a játékos egy területéről, egy másik, szomszédos, saját területére való katonák átcsoportosításának kezdetét jelenti.
Itt kell kiválasztani, hogy mely területről szeretnénk mozgatni.
Ugyan azt a metódust használja, mint a korábban kifejtett saját terület választásért felelős \CodeName{case} ág, de a jelenlegi fázisnak megfelelően nem a szomszédos ellenfelek listáját tölti fel, hanem a szomszédos szövetségesekét, illetve nem pirosra színezi ezeket a köröket, hanem zöldre, de ezeken kívül ugyan úgy működik. 

Megfelelő terület kiválasztására \CodeName{MOVE\_SELECT\_SECOND} fázisba lép a játék, mely alatt \CodeName{StackPane}-re történő kattintás során szintén azt a metódust hívja meg, mint amit a \CodeName{SELECT\_ENEMY} ág, de a mozgatással kapcsolatos ellenőrzések történnek rajta.
Ha olyan terület került kijelölésre, melyre lehetséges az átcsoportosítás, akkor megjelenik egy \CodeName{Pane}, melyen ki lehet választani az átcsoportosítandó katonák számát.
A JavaFX \CodeName{Slider} elemét használtam ennek az adatnak a bevitelére.
Átcsoportosítás csak olyan területről lehetséges, amelyen több, mint egy katona van, csak ilyenkor jelenik meg a korábban említett ehhez kapcsolódó \CodeName{Pane}.
A területen lévő katonák közül egyet mindenképpen ott kell hagyni, ezért a \CodeName{Slider}-en kiválasztható maximális érték az adott megyén lévő katonák számánál egyel kevesebb, a minimálisan választható pedig egy. 

A \CodeName{Slider}-re beállítottam egy \CodeName{Listener}-t, ami annak aktuális értékének változását figyeli, és ez az érték mindig frissen jelenik meg a \CodeName{Slider} alatt elhelyezett \CodeName{Label}-en. Az említett \CodeName{Pane} tartalmaz egy átcsoportosítás megerősítésére vonatkozó és egy visszalépésre gombot.
Előbbi megnyomásának hatására az elsőnek kijelölt megye katona számából levonásra kerül a \CodeName{Slider}-en kiválasztott mennyiségű katona, a másodiknak kijelölt terület katona mennyiségéhez pedig ez hozzáadódik, a GUI frissítésre kerül, és elkezdődik a gép köre.
A visszalépésre vonatkozó gomb megnyomására a fázis ismét \CodeName{MOVE\_SELECT\_FIRST} lesz, és az adott fázishoz tartozóan alaphelyzetbe áll a felület.
A fázis lezáró gomb megnyomásának hatására átugorható az átcsoportosítás és megkezdődik a gép köre.
A játékos körében mindegyik fázisban, ha a térképre történik kattintás a \CodeName{StackPane}-eken kívül, akkor a kör kijelölések visszavonásra kerülnek, és a megfelelő fázisba lép a játék. 

\subsection*{A gép köre}

Annak érdekében, hogy láthatóak legyenek a gép lépései, egy új szálat hoztam létre a gép körére vonatkozó esemény metódusán belül, melynek végrehajtása a program bizonyos pontjain szüneteltetésre kerül a \CodeName{java.lang.Thread} csomagja által nyújtott \CodeName{Thread.sleep()} metódus segítségével, ezzel hasonló hatást elérve, mintha a gép is úgy választaná ki a megyét, mint egy felhasználó.
Az új szál létrehozása miatt azokat a programrészeket, melyek a szálon belül módosításokat végeznek a GUI-n, JavaFX-ben a \CodeName{Platform.runLater()} metódusba kell beleírni, hogy megfelelően működjön a program, és helyesen megjelenítse a felületen történő változásokat. 

Hasonlóképpen, mint a játékos körének állapotainál, ebben az esetben is a \CodeName{GameEngine} osztály játékfázisaira vonatkozó \CodeName{Enum} objektumai kerülnek vizsgálatra \CodeName{switch-case} ágakkal.
Először beállításra kerül, hogy bizonyos gombnyomási funkciók ne váljanak elérhetővé a felhasználó számára.
Ezután a \CodeName{REINFORCE} fázisban a gép által birtokolt megyék id-je egy listába kerül eltárolásra, melyből véletlenszerűen kiválasztásra kerül egy, amire a felhasználható katonák kiosztásra kerülnek egyesével.
Ha ez megtörtént, létrejön egy olyan lista, melyre azok a gép által birtokolt területek kerülnek hozzáadásra, amelyekről támadni is tud.
Ezek közül véletlen számú területtel támad a körének támadási szakaszában. Az állapot \CodeName{SELECT\_REGION}-re kerül beállításra.
Ezen belül egy területének kiválasztásához egy listára kerül minden olyan \CodeName{StackPane}, mely a gép azon területeit jelöli, amin elegendő katona van a támadáshoz, illetve van neki olyan szomszédja, melyet meg tud támadni.
Ez a lista minden alkalommal kiürül, mielőtt ilyen területek gyűjtésére kerülne sor, mert a játék további állapotaiban változás történik a területekre vonatkozóan.
Ha ez a lista üres marad, akkor a gép nem tud támadni, ellenőrzésre kerül, hogy nyert-e valaki, és a játék állapota \CodeName{MOVE\_SELECT\_FIRST}-re változik. Ha nem maradt üres a lista, akkor ezek közül a \CodeName{Math.random()} függvény segítségével véletlenszerűen választ egyet, melyet átszínez, majd a játék a \CodeName{SELECT\_ENEMY} fázisba kerül. 

Itt ugyanaz a metódus kerül meghívásra, mint ennél az állapotnál a felhasználó esetében, de mivel paraméterben jelölve van, hogy melyik fél hívja meg, így ez alapján, ha a gép által kerül meghívásra, feltöltésre kerül egy lista, mely tartalmazza a gép által választott terület támadható szomszédjait.
Ezek közül kiválasztásra kerül egy terület, mely a felhasználó ellenfélválasztásához hasonló módon átszíneződik, majd a program átlép a támadási szakaszba.
Addig történnek a gép támadásai, amíg lehetősége van rá.
Ez annyiszor játszódik így le, amennyi az erősítés végén generált random szám.
Közben ellenőrzés történik arra, hogy van-e a játéknak nyertese. 

Amint ez lejátszódott, elkezdődik az átcsoportosítási szakasz.
Itt kiürítésre kerül a gép olyan köreinek listája, melyről támadást tud indítani, és feltöltődik azon köreivel, ahonnan át tud csoportosítani katonákat.
Ezek közül véletlenszerűen kiválasztásra kerül egy megye, melynek köre átszíneződik.
Ha nem tud ilyen területet választani, ellenőrzésre kerül, hogy nyert-e valamelyik fél és a játékos köre következik.
Amennyiben lehetősége van az átcsoportosításra, úgy a kiválasztott területről véletlen számú katonát visz át egy szomszédos megyére, úgy, hogy minimum egyet hátrahagy.
Ezután a játékos következik.
Ekkor ismét elérhetővé válnak a korábban letiltott gombok a felhasználó számára és új kör indul. 

\section{A Strava adatok eléréséért felelős és a játék osztályok kapcsolata}

Mivel két kontroller osztály található meg a projektben, biztosítani kell ezek egymással való kommunikációját.
Ehhez a játék kontroller osztályában létrehoztam egy metódust, mely beállítja az osztályhoz azt a \CodeName{Controller} objektumot, ami a metódus meghívásakor megadásra kerül benne. 

A \CodeName{Controller} osztályban pedig a következőképp állítottam ezt be egy olyan metóduson belül, mely a játék felületének megnyitásáért felel: 

\begin{lstlisting}[language=Java]
MapFXMLController mapController = new MapFXMLController();
FXMLLoader loader = new FXMLLoader(
  getClass().getClassLoader()
  .getResource("mapFXML.fxml"));
Parent root = (Parent) loader.load();
mapController = loader.<MapFXMLController>getController();
mapController.setController(this);
\end{lstlisting}

Lehetőség van az FXML fájl betöltéséért felelős \CodeName{FXMLLoader} objektumnak lekérni a kontrollerét, ezen keresztül állítottam be a játék kontroller osztályához a bejelentkezésért és a felhasználó adataiért felelős kontrollert.
Ezen kívül ebben a metódusban átadásra kerülnek a játék kontrollerének a betöltendő mentésre, valamint az új játékra vonatkozó adatok, melyet a \CodeName{GameEngine} példánya megkap paraméterben és így feltöltésre kerülnek a \CodeName{MapController}-ben a \CodeName{Country} objektumok. 

Ezután ellenőrzésre kerül, hogy érvényes-e még a felhasználóhoz tartozó korábban eltárolt Access Token, ha nem, akkor ez frissül, majd megtörténik a felhasználó aktivitási listájának frissítése és ehhez kapcsolódóan a pontok beállítása attól függően, hogy új játék kezdődött-e, vagy korábbi mentés került betöltésre.
A \CodeName{MapController} ez alapján megkapja a megfelelő kezdeti értékeket, melyeket az indításkor meg is jelenít a felületen. 

Mivel a felhasználó aktivitási adatai csak a játék erősítési fázisában számítanak, így a \CodeName{MapControllerben} a \CodeName{StackPane}-ekre vonatkozó eseménykezelőben a \CodeName{REINFORCE} ágban hozzáadásra kerültek különböző, pontok beállításáért felelős elágazások, melyek azt vizsgálják, hogy van-e egyáltalán a felhasználónak feltöltött aktivitása a Strava weboldalán, ha igen, akkor csak egy van-e, vagy több, és ezek szerint számolja a felhasználó pontjait, ebből következően pedig az erősítési fázisban lerakható maximális katonák számát állítja.
Amint egy katona elhelyezésre került a \CodeName{REINFORCE} fázisban, módosításra kerülnek a felhasználó elköltött és elérhető pontjai.
Minden 1000 méter megtétele után plusz egy lehelyezhető katona jár az erősítési fázisban.
Ha nem történt aktivitás a belépés óta, akkor csak egy katonát tehet le ebben a szakaszban. 

A játék felületén található egy frissítés gomb, ami a játékos körében bármikor elérhető, ez frissíti az Access Token-t, ha az lejárt, és ha történt aktivitás, akkor kiszámolja a megfelelő pontszámot, ennek alapján beállítja a játékos számára elérhető katonák számát és a megfelelő értékek megjelennek a GUI-n.
A JSON fájlba írásért és az ezekből való olvasásért a \CodeName{WriteAndReadJSON} osztályban található függvények felelnek. 

A fájlba írás során öt \CodeName{JSONArray}-be történik az adatok kiírása egy \CodeName{JSONObject}-en belül. Az első \CodeName{JSONArray}-ben a \CodeName{Country} objektumokra vonatkozó adatok kerülnek tárolásra, úgy, mint az id, a birtokos és a megyén található katonák száma.
A másodikban a játékmenet aktuális helyzetére vonatkozó információk vannak tárolva, vagyis hogy hányadik kör van éppen, melyik fázis, mennyi a letehető katonák száma, melyik játékos köre zajlik épp.
A harmadik \CodeName{JSONArray} a felhasználóra vonatkozó adatokat tartalmazza, melyekből a \CodeName{User} objektum értékei töltődnek fel. Ezek a következők:

\begin{itemize}
\setlength\itemsep{0em}
\item név
\item id
\item utolsó aktivitás id-je
\item az Access és a Refresh Token
\item az Access Token lejárati ideje
\item az eddig megtett összes út
\item az elköltött és felhasználható pontok
\item a játékba való első belépésekor lévő utolsó aktivitásának id-je
\end{itemize}

A negyedik \CodeName{JSONArray}-en a Strava app adatai találhatók meg, vagyis a Client Id és a Client Secret.
Tárolásra kerül még a játékban történő eddigi dobásokra vonatkozó lista is. 

A játék különböző pontjain történik automatikus mentés, a gép köre után, és a felhasználó fázisainak elején.
A felületen megjelenő kilépés gomb megnyomásának hatására is történik mentés.
Egy felhasználó csak egy mentéssel rendelkezik, a már létező mentés törlésre kerül új mentés hatására.
A mentett fájl neve tartalmazza a felhasználó id-jét. 

\section{Kinézet szerkesztése}

A felület kinézetének módosításához a JavaFX Cascading Style Sheets-et használtam.
Ez a W3C 2.1-es CSS verzióján alapul. Ez egy stílusleíró nyelv, mely segítségével meghatározhatjuk a felületen megjelenő különböző elemek megjelenését.
A JavaFX CSS a CSS olyan kiterjesztéseit tartalmazza, melyek különböző speciális JavaFX szolgáltatásokat is támogatnak.
Nem támogatja a CSS „\CodeName{float}”, „\CodeName{overflow}”, „\CodeName{position}” és a „\CodeName{width}” elrendezésre vonatkozó tulajdonságait, ezeket a JavaFX kódban kell beállítani.
Ezeken kívül, különböző HTML-specifikus elemekhez kapcsolódó beállításokat nem támogatja, mint például a táblák.
A JavaFX CSS fájljában a beállítandó tulajdonságok neve elé „\CodeName{-fx-}„ írandó. 

A programhoz egy CSS fájlt szerkesztettem, ez tartalmaz minden szükséges beállítást, melyek meg vannak adva a felületen a különféle, megjelenő elemeknek.
Itt szerepelnek a betűkre, gombokra, \CodeName{Label}-ekre, \CodeName{Slider}-re, a háttérre, a \CodeName{ScrollPane}-re és a benne lévő lista megjelenéséhez kapcsolódó információk.
Hogy ezek megjelenjenek a GUI-n, az FXML fájlban a megfelelő elemek tulajdonságainak felsorolásában szerepelnie kell a használandó CSS fájl nevének a következő módon:

\begin{lstlisting}[language=Java]
stylesheets="@style.css"
\end{lstlisting}


Ha egy elemre külön, a CSS fájl által tartalmazott \CodeName{.class} beállítást szeretnénk megadni, azt jelen esetben például a háttér beállítására vonatkozóan a \CodeName{style.css}-ben szereplő \CodeName{.background{}}-on belüli tulajdonságokat, azt a \CodeName{styleClass="background"} módon kell jelölni az FXML fájlban.
CSS fájltól függetlenül is lehetőség van megadni az FXML fájlban JavaFX CSS megjelenítési tulajdonságokat, mint például:

\begin{lstlisting}[language=Java]
style=
"-fx-background-color: #b38f6b;
 -fx-border-color: #5D544C;"
\end{lstlisting}
